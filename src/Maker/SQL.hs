{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

module Maker.SQL where

import Adventure.Engine
import Adventure.Engine.Database
import Adventure.Engine.Language
import qualified Data.Map as M
import Data.Text (Text)
import qualified Data.Text as T
import Data.Maybe (isJust, fromMaybe)

-- | Generate PostgreSQL schema and data for a World
generateWorldSQL :: World -> Text
generateWorldSQL world' = T.unlines
  [ "-- Adventure Engine World Data"
  , "-- Generated by adventure-maker"
  , ""
  , "BEGIN;"
  , ""
  , schemaSQL
  , ""
  , dataSQL world'
  , ""
  , "COMMIT;"
  ]

-- | PostgreSQL schema definition
schemaSQL :: Text
schemaSQL = T.unlines
  [ "-- Drop existing tables"
  , "DROP TABLE IF EXISTS container_lock_keys CASCADE;"
  , "DROP TABLE IF EXISTS container_items CASCADE;"
  , "DROP TABLE IF EXISTS exit_lock_keys CASCADE;"
  , "DROP TABLE IF EXISTS dig_definitions CASCADE;"
  , "DROP TABLE IF EXISTS room_exits CASCADE;"
  , "DROP TABLE IF EXISTS room_objects CASCADE;"
  , "DROP TABLE IF EXISTS exits CASCADE;"
  , "DROP TABLE IF EXISTS game_objects CASCADE;"
  , "DROP TABLE IF EXISTS rooms CASCADE;"
  , "DROP TABLE IF EXISTS player_state CASCADE;"
  , "DROP TABLE IF EXISTS player_verbs CASCADE;"
  , ""
  , "-- Rooms table"
  , "CREATE TABLE rooms ("
  , "  id INTEGER PRIMARY KEY,"
  , "  name TEXT NOT NULL,"
  , "  description TEXT NOT NULL,"
  , "  dig_enabled BOOLEAN NOT NULL DEFAULT false,"
  , "  dig_fail_message TEXT,"
  , "  background_image TEXT"
  , ");"
  , ""
  , "-- Game Objects table"
  , "CREATE TABLE game_objects ("
  , "  id INTEGER PRIMARY KEY,"
  , "  name TEXT NOT NULL,"
  , "  description TEXT NOT NULL,"
  , "  object_type TEXT NOT NULL CHECK (object_type IN ('item', 'container')),"
  , "  -- Item fields"
  , "  item_size INTEGER,"
  , "  item_weight INTEGER,"
  , "  -- Container fields"
  , "  container_size INTEGER,"
  , "  container_lock_fail_message TEXT,"
  , "  container_lock_success_message TEXT,"
  , "  container_lock_unlocked_desc TEXT,"
  , "  container_lock_state TEXT CHECK (container_lock_state IN ('locked', 'unlocked', NULL))"
  , ");"
  , ""
  , "-- Exits table"
  , "CREATE TABLE exits ("
  , "  id INTEGER PRIMARY KEY,"
  , "  name TEXT NOT NULL,"
  , "  description TEXT NOT NULL,"
  , "  from_room_id INTEGER NOT NULL REFERENCES rooms(id),"
  , "  to_room_id INTEGER NOT NULL REFERENCES rooms(id),"
  , "  -- Lock fields (NULL if not locked)"
  , "  lock_fail_message TEXT,"
  , "  lock_success_message TEXT,"
  , "  lock_state TEXT CHECK (lock_state IN ('locked', 'unlocked', NULL))"
  , ");"
  , ""
  , "-- Exit lock key items (junction table)"
  , "CREATE TABLE exit_lock_keys ("
  , "  exit_id INTEGER NOT NULL REFERENCES exits(id),"
  , "  key_item_id INTEGER NOT NULL REFERENCES game_objects(id),"
  , "  PRIMARY KEY (exit_id, key_item_id)"
  , ");"
  , ""
  , "-- Container items (junction table)"
  , "CREATE TABLE container_items ("
  , "  container_id INTEGER NOT NULL REFERENCES game_objects(id),"
  , "  item_name TEXT NOT NULL,"
  , "  item_id INTEGER NOT NULL REFERENCES game_objects(id),"
  , "  PRIMARY KEY (container_id, item_name)"
  , ");"
  , ""
  , "-- Container lock key items (junction table)"
  , "CREATE TABLE container_lock_keys ("
  , "  container_id INTEGER NOT NULL REFERENCES game_objects(id),"
  , "  key_item_id INTEGER NOT NULL REFERENCES game_objects(id),"
  , "  PRIMARY KEY (container_id, key_item_id)"
  , ");"
  , ""
  , "-- Room-Exit associations"
  , "CREATE TABLE room_exits ("
  , "  room_id INTEGER NOT NULL REFERENCES rooms(id),"
  , "  exit_name TEXT NOT NULL,"
  , "  exit_id INTEGER NOT NULL REFERENCES exits(id),"
  , "  PRIMARY KEY (room_id, exit_name)"
  , ");"
  , ""
  , "-- Room-Object associations"
  , "CREATE TABLE room_objects ("
  , "  room_id INTEGER NOT NULL REFERENCES rooms(id),"
  , "  object_name TEXT NOT NULL,"
  , "  object_id INTEGER NOT NULL REFERENCES game_objects(id),"
  , "  PRIMARY KEY (room_id, object_name)"
  , ");"
  , ""
  , "-- Dig definitions"
  , "CREATE TABLE dig_definitions ("
  , "  room_id INTEGER NOT NULL REFERENCES rooms(id),"
  , "  sequence_order INTEGER NOT NULL,"
  , "  success_message TEXT NOT NULL,"
  , "  game_object_id INTEGER REFERENCES game_objects(id),"
  , "  PRIMARY KEY (room_id, sequence_order)"
  , ");"
  , ""
  , "-- Player state"
  , "CREATE TABLE player_state ("
  , "  id INTEGER PRIMARY KEY DEFAULT 1,"
  , "  current_room_id INTEGER NOT NULL REFERENCES rooms(id),"
  , "  CHECK (id = 1)  -- Ensure only one player state row"
  , ");"
  , ""
  , "-- Player inventory"
  , "CREATE TABLE player_inventory ("
  , "  object_name TEXT NOT NULL PRIMARY KEY,"
  , "  object_id INTEGER NOT NULL REFERENCES game_objects(id)"
  , ");"
  , ""
  , "-- Player verb aliases"
  , "CREATE TABLE player_verbs ("
  , "  verb_alias TEXT NOT NULL PRIMARY KEY,"
  , "  verb_target TEXT NOT NULL"
  , ");"
  ]

-- | Generate SQL INSERT statements for world data
dataSQL :: World -> Text
dataSQL World{..} = T.unlines $
  [ "-- Insert Rooms"
  ] ++ roomInserts
  ++ [ ""
     , "-- Insert Game Objects"
     ] ++ objectInserts
  ++ [ ""
     , "-- Insert Exits"
     ] ++ exitInserts
  ++ [ ""
     , "-- Insert Exit Lock Keys"
     ] ++ exitLockKeyInserts
  ++ [ ""
     , "-- Insert Container Items"
     ] ++ containerItemInserts
  ++ [ ""
     , "-- Insert Container Lock Keys"
     ] ++ containerLockKeyInserts
  ++ [ ""
     , "-- Insert Room-Exit associations"
     ] ++ roomExitInserts
  ++ [ ""
     , "-- Insert Room-Object associations"
     ] ++ roomObjectInserts
  ++ [ ""
     , "-- Insert Dig Definitions"
     ] ++ digInserts
  ++ [ ""
     , "-- Insert Player State"
     ] ++ [playerStateInsert]
  ++ [ ""
     , "-- Insert Player Verbs"
     ] ++ verbInserts
  where
    roomInserts = map (roomToSQL) . M.toList $ _worldRooms
    objectInserts = map (gameObjectToSQL) . M.toList $ _worldObjects
    exitInserts = map (exitToSQL) . M.toList $ _worldExits
    exitLockKeyInserts = concatMap exitLockKeysToSQL . M.toList $ _worldExits
    containerItemInserts = concatMap containerItemsToSQL . M.toList $ _worldObjects
    containerLockKeyInserts = concatMap containerLockKeysToSQL . M.toList $ _worldObjects
    roomExitInserts = concatMap roomExitsToSQL . M.toList $ _worldRooms
    roomObjectInserts = concatMap roomObjectsToSQL . M.toList $ _worldRooms
    digInserts = concatMap roomDigsToSQL . M.toList $ _worldRooms
    playerStateInsert = playerStateToSQL _worldPlayerRoom
    verbInserts = map verbToSQL . M.toList $ _worldPlayerVerbs

-- | Convert a Room to SQL INSERT
roomToSQL :: (EntityId Room, Room) -> Text
roomToSQL (EntityId roomId, Room{..}) =
  let digEnabled = either (const False) (const True) _roomDig
      digFailMsg = either (Just . sqlQuote) (const Nothing) _roomDig
      background = fmap sqlQuote _roomBackground
  in T.concat
    [ "INSERT INTO rooms (id, name, description, dig_enabled, dig_fail_message, background_image) VALUES ("
    , T.pack . show $ roomId
    , ", "
    , sqlQuote _roomName
    , ", "
    , sqlQuote _roomDescription
    , ", "
    , if digEnabled then "true" else "false"
    , ", "
    , fromMaybe "NULL" digFailMsg
    , ", "
    , fromMaybe "NULL" background
    , ");"
    ]

-- | Convert a GameObject to SQL INSERT
gameObjectToSQL :: (EntityId GameObject, GameObject) -> Text
gameObjectToSQL (EntityId objId, GameObject{..}) =
  case _gameObjectObject of
    ObjectItem Item{..} -> T.concat
      [ "INSERT INTO game_objects (id, name, description, object_type, item_size, item_weight) VALUES ("
      , T.pack . show $ objId
      , ", "
      , sqlQuote _gameObjectName
      , ", "
      , sqlQuote _gameObjectDescription
      , ", 'item', "
      , T.pack . show $ _itemSize'
      , ", "
      , T.pack . show $ _itemWeight'
      , ");"
      ]
    ObjectContainer Container{..} ->
      let (lockFailMsg, lockSuccessMsg, unlockedDesc, lockState) = case _containerLock of
            Nothing -> ("NULL", "NULL", "NULL", "NULL")
            Just (ContainerLock lck unlockedDescription) ->
              ( sqlQuote (_lockFailMsg lck)
              , sqlQuote (_lockSuccessMsg lck)
              , sqlQuote unlockedDescription
              , sqlQuote $ case _lockState lck of
                  Locked -> "locked"
                  Unlocked -> "unlocked"
              )
      in T.concat
        [ "INSERT INTO game_objects (id, name, description, object_type, container_size, container_lock_fail_message, container_lock_success_message, container_lock_unlocked_desc, container_lock_state) VALUES ("
        , T.pack . show $ objId
        , ", "
        , sqlQuote _gameObjectName
        , ", "
        , sqlQuote _gameObjectDescription
        , ", 'container', "
        , T.pack . show $ _containerSize
        , ", "
        , lockFailMsg
        , ", "
        , lockSuccessMsg
        , ", "
        , unlockedDesc
        , ", "
        , lockState
        , ");"
        ]

-- | Convert an Exit to SQL INSERT
exitToSQL :: (EntityId Exit, Exit) -> Text
exitToSQL (EntityId exitId, Exit{..}) =
  let (lockFailMsg, lockSuccessMsg, lockState) = case _exitLock of
        Nothing -> ("NULL", "NULL", "NULL")
        Just (Lock _ failMsg successMsg state) ->
          ( sqlQuote failMsg
          , sqlQuote successMsg
          , sqlQuote $ case state of
              Locked -> "locked"
              Unlocked -> "unlocked"
          )
  in T.concat
    [ "INSERT INTO exits (id, name, description, from_room_id, to_room_id, lock_fail_message, lock_success_message, lock_state) VALUES ("
    , T.pack . show $ exitId
    , ", "
    , sqlQuote _exitName
    , ", "
    , sqlQuote _exitDescription
    , ", "
    , T.pack . show . getEntityId $ _exitFrom
    , ", "
    , T.pack . show . getEntityId $ _exitTo
    , ", "
    , lockFailMsg
    , ", "
    , lockSuccessMsg
    , ", "
    , lockState
    , ");"
    ]

-- | Convert exit lock keys to SQL INSERTs
exitLockKeysToSQL :: (EntityId Exit, Exit) -> [Text]
exitLockKeysToSQL (EntityId exitId, Exit{..}) =
  case _exitLock of
    Nothing -> []
    Just (Lock keyItems _ _ _) ->
      map (\(EntityId keyItemId) -> T.concat
        [ "INSERT INTO exit_lock_keys (exit_id, key_item_id) VALUES ("
        , T.pack . show $ exitId
        , ", "
        , T.pack . show $ keyItemId
        , ");"
        ]) keyItems

-- | Convert container items to SQL INSERTs
containerItemsToSQL :: (EntityId GameObject, GameObject) -> [Text]
containerItemsToSQL (EntityId containerId, GameObject{..}) =
  case _gameObjectObject of
    ObjectItem _ -> []
    ObjectContainer Container{..} ->
      map (\(itemName, EntityId itemId) -> T.concat
        [ "INSERT INTO container_items (container_id, item_name, item_id) VALUES ("
        , T.pack . show $ containerId
        , ", "
        , sqlQuote itemName
        , ", "
        , T.pack . show $ itemId
        , ");"
        ]) . M.toList $ _containerItems

-- | Convert container lock keys to SQL INSERTs
containerLockKeysToSQL :: (EntityId GameObject, GameObject) -> [Text]
containerLockKeysToSQL (EntityId containerId, GameObject{..}) =
  case _gameObjectObject of
    ObjectItem _ -> []
    ObjectContainer Container{..} ->
      case _containerLock of
        Nothing -> []
        Just (ContainerLock lck _) ->
          map (\(EntityId keyItemId) -> T.concat
            [ "INSERT INTO container_lock_keys (container_id, key_item_id) VALUES ("
            , T.pack . show $ containerId
            , ", "
            , T.pack . show $ keyItemId
            , ");"
            ]) $ _lockKeyItems lck

-- | Convert room exits to SQL INSERTs
roomExitsToSQL :: (EntityId Room, Room) -> [Text]
roomExitsToSQL (EntityId roomId, Room{..}) =
  map (\(exitName, EntityId exitId) -> T.concat
    [ "INSERT INTO room_exits (room_id, exit_name, exit_id) VALUES ("
    , T.pack . show $ roomId
    , ", "
    , sqlQuote exitName
    , ", "
    , T.pack . show $ exitId
    , ");"
    ]) . M.toList $ _roomExits

-- | Convert room objects to SQL INSERTs
roomObjectsToSQL :: (EntityId Room, Room) -> [Text]
roomObjectsToSQL (EntityId roomId, Room{..}) =
  map (\(objName, EntityId objId) -> T.concat
    [ "INSERT INTO room_objects (room_id, object_name, object_id) VALUES ("
    , T.pack . show $ roomId
    , ", "
    , sqlQuote objName
    , ", "
    , T.pack . show $ objId
    , ");"
    ]) . M.toList $ _roomObjects

-- | Convert room dig definitions to SQL INSERTs
roomDigsToSQL :: (EntityId Room, Room) -> [Text]
roomDigsToSQL (EntityId roomId, Room{..}) =
  case _roomDig of
    Left _ -> []
    Right digs -> zipWith (\order (DigDefinition successMsg mObjId) -> T.concat
      [ "INSERT INTO dig_definitions (room_id, sequence_order, success_message, game_object_id) VALUES ("
      , T.pack . show $ roomId
      , ", "
      , T.pack . show $ order
      , ", "
      , sqlQuote successMsg
      , ", "
      , maybe "NULL" (T.pack . show . getEntityId) mObjId
      , ");"
      ]) [1..] digs

-- | Convert player state to SQL INSERT
playerStateToSQL :: EntityId Room -> Text
playerStateToSQL (EntityId roomId) = T.concat
  [ "INSERT INTO player_state (id, current_room_id) VALUES (1, "
  , T.pack . show $ roomId
  , ");"
  ]

-- | Convert verb alias to SQL INSERT
verbToSQL :: (Verb, Verb) -> Text
verbToSQL (Verb alias, Verb target) = T.concat
  [ "INSERT INTO player_verbs (verb_alias, verb_target) VALUES ("
  , sqlQuote alias
  , ", "
  , sqlQuote target
  , ");"
  ]

-- | Quote and escape a SQL string literal
sqlQuote :: Text -> Text
sqlQuote txt = "'" <> T.replace "'" "''" txt <> "'"
